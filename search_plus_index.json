{"./":{"url":"./","title":"简介","keywords":"","body":"Introduction "},"distributed/":{"url":"distributed/","title":"分布式","keywords":"","body":"分布式 什么是分布式？ 分布式概念在198几年就已经出现了，当时单台计算机CPU、内存等硬件直接影响了软件的最大规模，为了突破这个限制，使用多台计算机共同协作来支撑同一软件的可行性的研究就开始了，其实就是一种解决单台计算机算力上限的解决方案。 对于开发来说，多个独立的分布式服务构建一个更大型系统，服务交互透明简单，不必关心是远程还是本地，对于用户来说，多台独立计算机构成的一个计算机集合，就像是同一台计算机一样。简单说就是在多台服务器部署同一项目，还要保证项目作为一个整体对外提供服务。 分布式系统的优缺点 优点 经济，多台廉价计算机组合比一台大型机有更好的性价比。 可靠性，一台服务器的系统崩溃并不影响到其余的服务器。 可扩展性，可以根据需要增加更多的机器。 模块化，所以系统模块重用度更高 …… 缺点 架构设计复杂，尤其是分布式事务，其实根据CAP和BASE理论，不可能在高可用分布式情况下做到一致性，一般都是最终一致性保证。 部署复杂，当然现在有k8s什么的服务编排好一点 故障排除复杂 系统吞吐量变大，相应的响应时间也变长 …… "},"distributed/transaction/transaction.html":{"url":"distributed/transaction/transaction.html","title":"分布式事务","keywords":"","body":"分布式事务 什么是分布式事务 "},"distributed/transaction/capacid.html":{"url":"distributed/transaction/capacid.html","title":"CAP与ACID","keywords":"","body":"CAP与ACID "},"distributed/transaction/eventqueue.html":{"url":"distributed/transaction/eventqueue.html","title":"可靠事件队列","keywords":"","body":"可靠事件队列 "},"distributed/transaction/tcc.html":{"url":"distributed/transaction/tcc.html","title":"TCC事务","keywords":"","body":"TCC事务 "},"distributed/transaction/saga.html":{"url":"distributed/transaction/saga.html","title":"SAGA事务","keywords":"","body":"SAGA事务 "},"distributed/lock/lock.html":{"url":"distributed/lock/lock.html","title":"分布式锁","keywords":"","body":"分布式锁 "},"distributed/lock/memcachelock.html":{"url":"distributed/lock/memcachelock.html","title":"Memcached实现","keywords":"","body":"Memcached实现 "},"distributed/lock/redislock.html":{"url":"distributed/lock/redislock.html","title":"Redis实现","keywords":"","body":"Redis实现 "},"distributed/lock/zoolock.html":{"url":"distributed/lock/zoolock.html","title":"Zookeeper实现","keywords":"","body":"Zookeeper实现 "},"distributed/lock/chubbylock.html":{"url":"distributed/lock/chubbylock.html","title":"Chubby实现","keywords":"","body":"Chubby实现 "},"distributed/cache/cache.html":{"url":"distributed/cache/cache.html","title":"分布式缓存","keywords":"","body":"分布式缓存 引入缓存理由 缓解CPU压力：譬如把方法运行 结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这可以节省CPU算力，顺带提升响应性能。 缓解I/O压力：譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩部件（如缓存中间件）的访问，顺带提升响应性能。 缓存是以空间换时间的策略，但是缓存的出发点是缓解CPU和I/O资源峰值压力，表现出来提升响应性能的结果。如果可以升级硬件提升性能则无必要使用缓存，避免无所谓的风险。 常用分布式缓存如下 redis 常用进程内缓存如下： ConcurrentHashMap Ehcache Guava Cache Caffiene 性能 最高 一般 良好 优秀（接近ConcurrentHashMap） 淘汰策略 无 支持多种淘汰策略FIFO、LRU、LFU等 LRU W-TinyLFU 其他功能 无 并发级别控制失效策略容量控制事件通知统计信息…… 并发级别控制失效策略容量控制事件通知统计信息…… 并发级别控制失效策略容量控制事件通知统计信息…… "},"distributed/cache/cacheprop.html":{"url":"distributed/cache/cacheprop.html","title":"缓存属性","keywords":"","body":"缓存属性 吞吐量：OPS（每秒操作数，Operations per Second）值，反应缓存并发读写效率 命中率：从缓存中返回结果与缓存请求次数比，反应缓存价值的高低 其他功能：管理功能（失效、刷新、命中统计、当前缓存量等）、分布式支持。 "},"distributed/cache/ops.html":{"url":"distributed/cache/ops.html","title":"吞吐量","keywords":"","body":"吞吐量 "},"distributed/cache/hitrate.html":{"url":"distributed/cache/hitrate.html","title":"命中率","keywords":"","body":"命中率 "},"distributed/cache/expired.html":{"url":"distributed/cache/expired.html","title":"过期策略","keywords":"","body":"过期策略 "},"distributed/cache/eliminated.html":{"url":"distributed/cache/eliminated.html","title":"淘汰策略","keywords":"","body":"淘汰策略 FIFO（First In First Out）：优先淘汰最早进入被缓存的数据。FIFO实现很简单，但一般来说它并不是优秀的淘汰策略，越是频繁被用到的数据，往往会越早被存入缓存之中。如果采用这种淘汰策略，很可能会大幅降低缓存的命中率。 LRU（Least Recent Used）：优先淘汰最久未被使用访问过的数据。LRU通常会采用HashMap加LinkedList双重结构（如LinkedHashMap）来实现，以HashMap来提供访问接口，保证常量时间复杂度的读取性能，以LinkedList的链表元素顺序来表示数据的时间顺序，每次缓存命中时把返回对象调整到LinkedList开头，每次缓存淘汰时从链表末端开始清理数据。对大多数的缓存场景来说，LRU都明显要比FIFO策略合理，尤其适合用来处理短时间内频繁访问的热点对象。但相反，它的问题是如果一些热点数据在系统中经常被频繁访问，但最近几分钟因为某种原因未被访问过，此时这些热点数据依然要面临淘汰的命运，LRU依然可能错误淘汰价值更高的数据。 LFU（Least Frequently Used）：优先淘汰最不经常使用的数据。LFU会给每个数据添加一个访问计数器，每访问一次就加1，需要淘汰时就清理计数器数值最小的那批数据。LFU可以解决上面LRU中热点数据间隔一段时间不访问就被淘汰的问题，LFU会引入两个新的问题，一个是需要对每个缓存的数据专门去维护一个计数器，每次访问都要更新，这会带来高昂的开销；另一个问题是不便于处理随时间变化的热度变化，譬如某个曾经频繁访问的数据现在不需要了，它也很难自动被清理出缓存。 TinyLFU（Tiny Least Frequently Used）：LFU的改进版本，LFU第一个问题：采用Sketch对访问数据进行分析，用少量的样本数据来估计全体数据的特征，得出的种高效与准确之间权衡的有效结论；第二个问题：采用了基于“滑动时间窗”的热衰减算法，每隔一段时间把计数器的数值减半，解决“旧热点”数据难以清除的问题 W-TInyLFU（Windows-TinyLFU）： ARC（Adaptive Replacement Cache）： LIRS（Low Inter-Reference Recency Set）： "},"distributed/cache/cacherisk.html":{"url":"distributed/cache/cacherisk.html","title":"缓存风险","keywords":"","body":"缓存风险 "},"distributed/cache/cachepenetrate.html":{"url":"distributed/cache/cachepenetrate.html","title":"缓存穿透","keywords":"","body":"缓存穿透 所谓缓存穿透，就是请求的数据在数据库中不存在，缓存里自然也没有，所以每次请求都是透过缓存去请求数据库，这种查询不存在数据的现象为缓存穿透。 业务逻辑问题 如果业务逻辑不可避免查询不存在的数据，可以缓存一个空的结果，将缓存设置一个较短的失效时间，后续插入值的时候可以清理掉缓存。 恶意攻击导致 加一个布隆过滤器，使用较小的代价过滤掉大概率不存在的请求，直接返回 "},"distributed/cache/cachebreakdown.html":{"url":"distributed/cache/cachebreakdown.html","title":"缓存击穿","keywords":"","body":"缓存击穿 所谓缓存击穿，就是缓存中的热点数据忽然失效了（典型原因超时），这时又有许多请求去查询缓存，查不到后去查询数据库，导致数据库压力剧增，这种热点数据自动失效导致数据库压力剧增的现象为缓存穿透。 查询加锁 针对热点数据查询数据库时使用查询的key加锁，避免多个请求同时到达数据库。 手工管理 热点数据使用代码有计划的刷新。 "},"distributed/cache/cacheavalanche.html":{"url":"distributed/cache/cacheavalanche.html","title":"缓存雪崩","keywords":"","body":"缓存雪崩 "},"distributed/cache/cachepollution.html":{"url":"distributed/cache/cachepollution.html","title":"缓存污染","keywords":"","body":"缓存污染 "},"jvm/":{"url":"jvm/","title":"JVM虚拟机","keywords":"","body":"JVM虚拟机 "},"jvm/垃圾收集算法.html":{"url":"jvm/垃圾收集算法.html","title":"垃圾收集","keywords":"","body":"垃圾收集算法 "},"dsalgo/":{"url":"dsalgo/","title":"数据结构与算法","keywords":"","body":"数据结构与算法 "},"dsalgo/ds/":{"url":"dsalgo/ds/","title":"数据结构","keywords":"","body":"数据结构 "},"dsalgo/ds/数组.html":{"url":"dsalgo/ds/数组.html","title":"数组","keywords":"","body":"数组 "},"dsalgo/ds/栈.html":{"url":"dsalgo/ds/栈.html","title":"栈","keywords":"","body":"栈 "},"dsalgo/ds/队列.html":{"url":"dsalgo/ds/队列.html","title":"队列","keywords":"","body":"队列 "},"dsalgo/ds/链表.html":{"url":"dsalgo/ds/链表.html","title":"链表","keywords":"","body":"链表 "},"dsalgo/ds/树.html":{"url":"dsalgo/ds/树.html","title":"树","keywords":"","body":"树 "},"dsalgo/ds/二叉树.html":{"url":"dsalgo/ds/二叉树.html","title":"二叉树","keywords":"","body":"二叉树 "},"dsalgo/ds/完全二叉树.html":{"url":"dsalgo/ds/完全二叉树.html","title":"完全二叉树","keywords":"","body":"完全二叉树 "},"dsalgo/ds/平衡二叉树.html":{"url":"dsalgo/ds/平衡二叉树.html","title":"平衡二叉树","keywords":"","body":"平衡二叉树 "},"dsalgo/ds/二叉查找树.html":{"url":"dsalgo/ds/二叉查找树.html","title":"二叉查找树（BST）","keywords":"","body":"二叉查找树（BST） "},"dsalgo/ds/B树.html":{"url":"dsalgo/ds/B树.html","title":"B，B+，B*树","keywords":"","body":"B，B+，B*树 "},"dsalgo/ds/LSM树.html":{"url":"dsalgo/ds/LSM树.html","title":"LSM 树","keywords":"","body":"LSM 树 "},"dsalgo/algo/":{"url":"dsalgo/algo/","title":"常用算法","keywords":"","body":"常用算法 "},"dsalgo/algo/插入排序.html":{"url":"dsalgo/algo/插入排序.html","title":"插入排序","keywords":"","body":"插入排序 "},"middleware/":{"url":"middleware/","title":"中间件","keywords":"","body":"中间件 "},"middleware/redis/redisintro.html":{"url":"middleware/redis/redisintro.html","title":"redis ","keywords":"","body":"Redis "},"middleware/redis/redistctd.html":{"url":"middleware/redis/redistctd.html","title":"淘汰策略","keywords":"","body":"淘汰策略 当使用的内存超过配置的maxmemory后会触发内存淘汰，淘汰策略可通过修改配置文件redis.conf 的 maxmemory-policy选项配置。 volatile-lru：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 。 allkeys-lru： 利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。通常使用该方式。 volatile-random：移除设置过过期时间的随机key 。 allkeys-random：无差别的随机移除。 volatile-ttl：移除即将过期的key(minor TTL) noeviction：不移除任何key，只是返回一个写错误 ，默认选项，一般不会选用。 "},"middleware/redis/redisgoqi.html":{"url":"middleware/redis/redisgoqi.html","title":"过期策略","keywords":"","body":"过期策略 Redis惰性删除和定期删除两种策略配合使用，惰性删除没每次读写都会执行；定期删除可以通过修改配置文件redis.conf 的 hz选项配置。 定时删除 在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。 优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。 缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。 惰性删除 设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。 优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。 缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。 定期删除 每隔一段时间，我们就对一些key进行检查，删除里面过期的key。 优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。 缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。 难点：合理设置执行时常（每次删除执行多长时间）和执行频率（多长时间执行一次删除） "},"javacode/":{"url":"javacode/","title":"Java 源码","keywords":"","body":"Java 源码 "},"javacode/hashmap.html":{"url":"javacode/hashmap.html","title":"HashMap","keywords":"","body":"HashMap "},"javacode/arraylist.html":{"url":"javacode/arraylist.html","title":"ArrayList","keywords":"","body":"ArrayList "}}